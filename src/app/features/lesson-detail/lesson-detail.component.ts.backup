import { Component, OnInit, OnDestroy, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Subject, forkJoin } from 'rxjs';
import { takeUntil, catchError } from 'rxjs/operators';

import { Lesson, LessonResource, StudentLesson, LessonProgress } from '../../models/lesson.models';
import { LessonsService } from '../../core/services/lessons.service';
import { AuthService } from '../../core/services/auth.service';
import { ExamService } from '../../core/services/exam.service';
import { NotesService, Note, CreateNoteDto, UpdateNoteDto } from '../../core/services/notes.service';
import { LessonQuestionsService, LessonQuestion, CreateLessonQuestionDto } from '../../core/services/lesson-questions.service';
import { Exam, ExamDetails, StudentExamSession, ExamSubmission, ExamAnswer, ExamResult, QuestionType } from '../../models/exam.models';
import { ToastService } from '../../core/services/toast.service';

interface Quiz {
  id: number;
  question: string;
  options: string[];
  correctAnswer: number;
  explanation?: string;
  timeLimit?: number; // in minutes
}

interface VideoChapter {
  id: number;
  title: string;
  startTime: number; // in seconds
  endTime: number; // in seconds
  description?: string;
}

interface QuizQuestion {
  id: number;
  question: string;
  options: string[];
  correctAnswer: number;
  explanation?: string;
  points: number;
}

interface QuizMaker {
  id: number;
  lessonId: number;
  title: string;
  description: string;
  timeLimit: number; // in minutes
  questions: QuizQuestion[];
  passingScore: number;
  isActive: boolean;
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
}

@Component({
  selector: 'app-lesson-detail',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './lesson-detail.component.html',
  styleUrls: ['./lesson-detail.component.scss']
})
export class LessonDetailComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();

  // State signals
  lesson = signal<Lesson | null>(null);
  studentLesson = signal<StudentLesson | null>(null);
  loading = signal(false);
  error = signal<string | null>(null);

  // Lesson navigation
  nextLesson = signal<Lesson | null>(null);
  previousLesson = signal<Lesson | null>(null);

  // Video player state
  videoCurrentTime = signal(0);
  videoDuration = signal(0);
  isVideoPlaying = signal(false);
  videoProgress = signal(0);

  // Video chapters
  videoChapters = signal<VideoChapter[]>([]);
  currentChapter = signal<VideoChapter | null>(null);
  isEditingChapters = signal(false);
  chapterForm: FormGroup;

  // Exams state (from backend)
  lessonExams = signal<Exam[]>([]);
  currentExam = signal<ExamDetails | null>(null);
  currentExamSession = signal<StudentExamSession | null>(null);
  examAnswers = signal<ExamAnswer[]>([]);
  examResult = signal<ExamResult | null>(null);
  isLoadingExam = signal(false);
  isSubmittingExam = signal(false);
  showExamResults = signal(false);

  // Quiz state (legacy - keeping for compatibility)
  quizzes = signal<Quiz[]>([]);
  currentQuizIndex = signal(0);
  quizAnswers = signal<number[]>([]);
  showQuizResults = signal(false);
  quizScore = signal(0);

  // Quiz Maker state
  quizMakers = signal<QuizMaker[]>([]);
  isCreatingQuiz = signal(false);
  isEditingQuiz = signal(false);
  currentQuizMaker = signal<QuizMaker | null>(null);
  quizMakerForm: FormGroup;
  quizQuestionForm: FormGroup;

  // Notes state (from backend)
  notes = signal<Note[]>([]);
  noteForm: FormGroup;
  isAddingNote = signal(false);
  isLoadingNotes = signal(false);

  // Teacher interaction state (from backend)
  teacherQuestions = signal<LessonQuestion[]>([]);
  questionForm: FormGroup;
  isAskingQuestion = signal(false);
  isLoadingQuestions = signal(false);

  // Active tab
  activeTab = signal<'video' | 'resources' | 'quiz' | 'notes' | 'teacher' | 'chapters' | 'quiz-maker' | 'exams'>('video');

  // Computed values
  currentQuiz = computed(() => {
    const quizzes = this.quizzes();
    const index = this.currentQuizIndex();
    return quizzes[index] || null;
  });

  hasQuizzes = computed(() => this.quizzes().length > 0);
  hasExams = computed(() => this.lessonExams().length > 0);
  quizProgress = computed(() => {
    const total = this.quizzes().length;
    const current = this.currentQuizIndex() + 1;
    return total > 0 ? (current / total) * 100 : 0;
  });

  // Additional computed properties
  hasNextLesson = computed(() => this.nextLesson() !== null);
  hasPreviousLesson = computed(() => this.previousLesson() !== null);
  hasChapters = computed(() => this.videoChapters().length > 0);
  canEditContent = computed(() => {
    if (!this.authService.isAuthenticated()) return false;
    return this.authService.hasAnyRole(['teacher', 'admin']);
  });
  hasQuizMakers = computed(() => this.quizMakers().length > 0);

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private lessonsService: LessonsService,
    private authService: AuthService,
    private examService: ExamService,
    private notesService: NotesService,
    private lessonQuestionsService: LessonQuestionsService,
    private toastService: ToastService,
    private fb: FormBuilder
  ) {
    this.noteForm = this.fb.group({
      content: ['', [Validators.required, Validators.minLength(10)]]
    });

    this.questionForm = this.fb.group({
      question: ['', [Validators.required, Validators.minLength(10)]]
    });

    this.chapterForm = this.fb.group({
      title: ['', [Validators.required, Validators.minLength(3)]],
      startTime: [0, [Validators.required, Validators.min(0)]],
      endTime: [0, [Validators.required, Validators.min(0)]],
      description: ['']
    });

    this.quizMakerForm = this.fb.group({
      title: ['', [Validators.required, Validators.minLength(3)]],
      description: ['', [Validators.required]],
      timeLimit: [30, [Validators.required, Validators.min(1)]],
      passingScore: [70, [Validators.required, Validators.min(0), Validators.max(100)]],
      isActive: [true]
    });

    this.quizQuestionForm = this.fb.group({
      question: ['', [Validators.required, Validators.minLength(10)]],
      option1: ['', [Validators.required]],
      option2: ['', [Validators.required]],
      option3: ['', [Validators.required]],
      option4: ['', [Validators.required]],
      correctAnswer: [0, [Validators.required, Validators.min(0), Validators.max(3)]],
      explanation: [''],
      points: [1, [Validators.required, Validators.min(1)]]
    });
  }

  ngOnInit(): void {
    this.route.params
      .pipe(takeUntil(this.destroy$))
      .subscribe(params => {
        const lessonId = parseInt(params['id']);
        if (lessonId) {
          this.loadLesson(lessonId);
          this.loadAdjacentLessons(lessonId);
          this.loadVideoChapters(lessonId);
          this.loadQuizMakers(lessonId);
          
          // Load backend data
          if (this.authService.isAuthenticated()) {
            this.loadLessonExams(lessonId);
            this.loadLessonNotes(lessonId);
            this.loadLessonQuestions(lessonId);
          }
        }
      });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // ==================== BACKEND INTEGRATION METHODS ====================

  /**
   * Load exams for this lesson from backend
   */
  private loadLessonExams(lessonId: number): void {
    this.examService.getExamsByLesson(lessonId)
      .pipe(
        takeUntil(this.destroy$),
        catchError(error => {
          console.error('Error loading lesson exams:', error);
          this.toastService.error('Failed to load exams');
          return [];
        })
      )
      .subscribe({
        next: (exams) => {
          this.lessonExams.set(exams);
          console.log(`Loaded ${exams.length} exams for lesson ${lessonId}`);
        }
      });
  }

  /**
   * Load notes for this lesson from backend
   */
  private loadLessonNotes(lessonId: number): void {
    this.isLoadingNotes.set(true);
    this.notesService.getNotesByLesson(lessonId)
      .pipe(
        takeUntil(this.destroy$),
        catchError(error => {
          console.error('Error loading notes:', error);
          this.toastService.error('Failed to load notes');
          return [];
        })
      )
      .subscribe({
        next: (notes) => {
          this.notes.set(notes);
          this.isLoadingNotes.set(false);
          console.log(`Loaded ${notes.length} notes for lesson ${lessonId}`);
        },
        error: () => {
          this.isLoadingNotes.set(false);
        }
      });
  }

  /**
   * Load questions for this lesson from backend
   */
  private loadLessonQuestions(lessonId: number): void {
    this.isLoadingQuestions.set(true);
    this.lessonQuestionsService.getQuestionsByLesson(lessonId)
      .pipe(
        takeUntil(this.destroy$),
        catchError(error => {
          console.error('Error loading questions:', error);
          this.toastService.error('Failed to load questions');
          return [];
        })
      )
      .subscribe({
        next: (questions) => {
          this.teacherQuestions.set(questions);
          this.isLoadingQuestions.set(false);
          console.log(`Loaded ${questions.length} questions for lesson ${lessonId}`);
        },
        error: () => {
          this.isLoadingQuestions.set(false);
        }
      });
  }

  /**
   * Start an exam
   */
  startExam(exam: Exam): void {
    this.isLoadingExam.set(true);
    
    this.examService.startExam(exam.id)
      .pipe(
        takeUntil(this.destroy$),
        catchError(error => {
          console.error('Error starting exam:', error);
          this.toastService.error('Failed to start exam');
          this.isLoadingExam.set(false);
          throw error;
        })
      )
      .subscribe({
        next: (session) => {
          this.currentExamSession.set(session);
          this.examAnswers.set([]);
          this.showExamResults.set(false);
          this.setActiveTab('exams');
          this.isLoadingExam.set(false);
          this.toastService.success('Exam started successfully');
        }
      });
  }

  /**
   * Submit exam answers
   */
  submitExam(): void {
    const session = this.currentExamSession();
    if (!session) return;

    if (confirm('Are you sure you want to submit your exam? This action cannot be undone.')) {
      this.isSubmittingExam.set(true);

      const submission: ExamSubmission = {
        studentExamId: session.studentExamId,
        answers: this.examAnswers()
      };

      this.examService.submitExam(submission)
        .pipe(
          takeUntil(this.destroy$),
          catchError(error => {
            console.error('Error submitting exam:', error);
            this.toastService.error('Failed to submit exam');
            this.isSubmittingExam.set(false);
            throw error;
          })
        )
        .subscribe({
          next: (result) => {
            this.examResult.set(result);
            this.showExamResults.set(true);
            this.isSubmittingExam.set(false);
            this.toastService.success('Exam submitted successfully');
          }
        });
    }
  }

  /**
   * Save exam answer
   */
  saveExamAnswer(questionId: number, answer: ExamAnswer): void {
    const currentAnswers = this.examAnswers();
    const existingIndex = currentAnswers.findIndex(a => a.questionId === questionId);

    if (existingIndex >= 0) {
      currentAnswers[existingIndex] = answer;
    } else {
      currentAnswers.push(answer);
    }

    this.examAnswers.set([...currentAnswers]);
  }

  /**
   * Get saved answer for a question
   */
  getExamAnswer(questionId: number): ExamAnswer | undefined {
    return this.examAnswers().find(a => a.questionId === questionId);
  }

  /**
   * Close exam and go back to exams list
   */
  closeExam(): void {
    this.currentExamSession.set(null);
    this.currentExam.set(null);
    this.examAnswers.set([]);
    this.examResult.set(null);
    this.showExamResults.set(false);
  }

  // ==================== NOTES METHODS (Backend Integrated) ====================

  /**
   * Add note to backend
   */
  addNote(): void {
    if (this.noteForm.valid && this.lesson()) {
      this.isAddingNote.set(true);

      const dto: CreateNoteDto = {
        content: this.noteForm.value.content,
        lessonId: this.lesson()!.id,
        timestamp: Math.floor(this.videoCurrentTime())
      };

      this.notesService.createNote(dto)
        .pipe(
          takeUntil(this.destroy$),
          catchError(error => {
            console.error('Error creating note:', error);
            this.toastService.error('Failed to create note');
            this.isAddingNote.set(false);
            throw error;
          })
        )
        .subscribe({
          next: (note) => {
            const currentNotes = this.notes();
            this.notes.set([...currentNotes, note]);
            this.noteForm.reset();
            this.isAddingNote.set(false);
            this.toastService.success('Note added successfully');
          }
        });
    }
  }

  /**
   * Delete note from backend
   */
  deleteNote(noteId: number): void {
    if (confirm('Are you sure you want to delete this note?')) {
      this.notesService.deleteNote(noteId)
        .pipe(
          takeUntil(this.destroy$),
          catchError(error => {
            console.error('Error deleting note:', error);
            this.toastService.error('Failed to delete note');
            throw error;
          })
        )
        .subscribe({
          next: () => {
            const currentNotes = this.notes();
            this.notes.set(currentNotes.filter(note => note.id !== noteId));
            this.toastService.success('Note deleted successfully');
          }
        });
    }
  }

  /**
   * Toggle note favorite status
   */
  toggleNoteFavorite(note: Note): void {
    this.notesService.toggleFavorite(note.id)
      .pipe(
        takeUntil(this.destroy$),
        catchError(error => {
          console.error('Error toggling favorite:', error);
          this.toastService.error('Failed to update note');
          throw error;
        })
      )
      .subscribe({
        next: (updatedNote) => {
          const currentNotes = this.notes();
          const index = currentNotes.findIndex(n => n.id === updatedNote.id);
          if (index >= 0) {
            currentNotes[index] = updatedNote;
            this.notes.set([...currentNotes]);
          }
        }
      });
  }

  /**
   * Jump to note timestamp in video
   */
  jumpToNoteTimestamp(note: Note): void {
    if (note.timestamp) {
      this.seekToTime(note.timestamp);
      this.setActiveTab('video');
      this.toastService.info(`Jumped to ${this.formatTime(note.timestamp)}`);
    }
  }

  // ==================== TEACHER QUESTIONS METHODS (Backend Integrated) ====================

  /**
   * Ask teacher a question
   */
  askTeacher(): void {
    if (this.questionForm.valid && this.lesson()) {
      this.isAskingQuestion.set(true);

      const dto: CreateLessonQuestionDto = {
        lessonId: this.lesson()!.id,
        questionText: this.questionForm.value.question
      };

      this.lessonQuestionsService.createQuestion(dto)
        .pipe(
          takeUntil(this.destroy$),
          catchError(error => {
            console.error('Error creating question:', error);
            this.toastService.error('Failed to send question');
            this.isAskingQuestion.set(false);
            throw error;
          })
        )
        .subscribe({
          next: (question) => {
            const currentQuestions = this.teacherQuestions();
            this.teacherQuestions.set([...currentQuestions, question]);
            this.questionForm.reset();
            this.isAskingQuestion.set(false);
            this.toastService.success('Question sent to teacher successfully');
          }
        });
    }
  }

  /**
   * Delete a question
   */
  deleteQuestion(questionId: number): void {
    if (confirm('Are you sure you want to delete this question?')) {
      this.lessonQuestionsService.deleteQuestion(questionId)
        .pipe(
          takeUntil(this.destroy$),
          catchError(error => {
            console.error('Error deleting question:', error);
            this.toastService.error('Failed to delete question');
            throw error;
          })
        )
        .subscribe({
          next: () => {
            const currentQuestions = this.teacherQuestions();
            this.teacherQuestions.set(currentQuestions.filter(q => q.id !== questionId));
            this.toastService.success('Question deleted successfully');
          }
        });
    }
  }

  // ==================== EXISTING METHODS (Preserved) ====================

  /**
   * Load lesson details
   */
  private loadLesson(lessonId: number): void {
    this.loading.set(true);
    this.error.set(null);

    this.lessonsService.getLessonById(lessonId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (lesson) => {
          if (lesson) {
            this.lesson.set(lesson);
            this.loadMockQuizzes(lessonId);

            // Load student progress if authenticated
            if (this.authService.isAuthenticated()) {
              this.loadStudentProgress(lessonId);
            }
          } else {
            this.error.set('Lesson not found');
          }
          this.loading.set(false);
        },
        error: (error) => {
          this.error.set('Failed to load lesson');
          this.loading.set(false);
          console.error('Error loading lesson:', error);
        }
      });
  }

  /**
   * Load student progress for this lesson
   */
  private loadStudentProgress(lessonId: number): void {
    const studentId = 1; // Mock student ID - should come from auth service

    this.lessonsService.getStudentLessons(studentId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (studentLessons) => {
          const studentLesson = studentLessons.find(sl => sl.lesson.id === lessonId);
          this.studentLesson.set(studentLesson || null);
        },
        error: (error) => {
          console.error('Error loading student progress:', error);
        }
      });
  }

  /**
   * Load mock quizzes for the lesson (legacy)
   */
  private loadMockQuizzes(lessonId: number): void {
    const mockQuizzes: Quiz[] = [
      {
        id: 1,
        question: "What is the main topic of this lesson?",
        options: [
          "Mathematics fundamentals",
          "English grammar",
          "Science experiments",
          "History facts"
        ],
        correctAnswer: 0,
        explanation: "This lesson focuses on mathematics fundamentals as stated in the introduction."
      },
      {
        id: 2,
        question: "Which method was demonstrated in the video?",
        options: [
          "Addition method",
          "Subtraction method",
          "Multiplication method",
          "Division method"
        ],
        correctAnswer: 2,
        explanation: "The video demonstrated the multiplication method with several examples."
      }
    ];

    this.quizzes.set(mockQuizzes);
    this.quizAnswers.set(new Array(mockQuizzes.length).fill(-1));
  }

  /**
   * Load adjacent lessons for navigation
   */
  private loadAdjacentLessons(currentLessonId: number): void {
    this.lessonsService.getLessons()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (lessons) => {
          const currentLesson = this.lesson();
          if (!currentLesson) return;

          const sameCourse = lessons.filter(l =>
            l.subject === currentLesson.subject &&
            l.courseId === currentLesson.courseId
          ).sort((a, b) => (a.order || 0) - (b.order || 0));

          const currentIndex = sameCourse.findIndex(l => l.id === currentLessonId);

          if (currentIndex > 0) {
            this.previousLesson.set(sameCourse[currentIndex - 1]);
          }

          if (currentIndex < sameCourse.length - 1) {
            this.nextLesson.set(sameCourse[currentIndex + 1]);
          }
        },
        error: (error) => {
          console.error('Error loading adjacent lessons:', error);
        }
      });
  }

  /**
   * Load video chapters for the lesson
   */
  private loadVideoChapters(lessonId: number): void {
    const mockChapters: VideoChapter[] = [
      {
        id: 1,
        title: 'Introduction',
        startTime: 0,
        endTime: 120,
        description: 'Welcome and lesson overview'
      },
      {
        id: 2,
        title: 'Main Content',
        startTime: 120,
        endTime: 1800,
        description: 'Core learning material'
      },
      {
        id: 3,
        title: 'Practice Examples',
        startTime: 1800,
        endTime: 2400,
        description: 'Worked examples and practice'
      },
      {
        id: 4,
        title: 'Summary',
        startTime: 2400,
        endTime: 2700,
        description: 'Lesson recap and next steps'
      }
    ];

    this.videoChapters.set(mockChapters);
    this.updateCurrentChapter();
  }

  /**
   * Load quiz makers for the lesson
   */
  private loadQuizMakers(lessonId: number): void {
    const mockQuizMakers: QuizMaker[] = [
      {
        id: 1,
        lessonId: lessonId,
        title: 'Lesson Comprehension Quiz',
        description: 'Test your understanding of the main concepts',
        timeLimit: 20,
        questions: [
          {
            id: 1,
            question: 'What is the main topic of this lesson?',
            options: ['Mathematics', 'Science', 'English', 'History'],
            correctAnswer: 0,
            explanation: 'The lesson focuses on mathematical concepts',
            points: 2
          },
          {
            id: 2,
            question: 'Which method is demonstrated in the video?',
            options: ['Addition', 'Subtraction', 'Multiplication', 'Division'],
            correctAnswer: 2,
            explanation: 'The video demonstrates multiplication techniques',
            points: 3
          }
        ],
        passingScore: 70,
        isActive: true,
        createdBy: 'Teacher Smith',
        createdAt: new Date(Date.now() - 86400000),
        updatedAt: new Date(Date.now() - 43200000)
      }
    ];

    this.quizMakers.set(mockQuizMakers);
  }

  /**
   * Set active tab
   */
  setActiveTab(tab: 'video' | 'resources' | 'quiz' | 'notes' | 'teacher' | 'chapters' | 'quiz-maker' | 'exams'): void {
    this.activeTab.set(tab);
  }

  /**
   * Update current chapter based on video time
   */
  private updateCurrentChapter(): void {
    const currentTime = this.videoCurrentTime();
    const chapters = this.videoChapters();

    const current = chapters.find(chapter =>
      currentTime >= chapter.startTime && currentTime <= chapter.endTime
    );

    this.currentChapter.set(current || null);
  }

  /**
   * Video player methods
   */
  onVideoTimeUpdate(event: any): void {
    const currentTime = event.target.currentTime;
    const duration = event.target.duration;
    this.videoCurrentTime.set(currentTime);
    this.videoDuration.set(duration);
    this.videoProgress.set(duration > 0 ? (currentTime / duration) * 100 : 0);

    this.updateCurrentChapter();
  }

  onVideoPlay(): void {
    this.isVideoPlaying.set(true);
  }

  onVideoPause(): void {
    this.isVideoPlaying.set(false);
  }

  onVideoLoadedMetadata(event: any): void {
    const duration = event.target.duration;
    this.videoDuration.set(duration);
  }

  onVideoError(event: any): void {
    console.error('Video playback error:', event);
    this.toastService.error('Video playback error');
  }

  playVideo(): void {
    const videoElement = document.querySelector('video') as HTMLVideoElement;
    if (videoElement) {
      videoElement.play();
    }
  }

  seekToTime(timestamp: number): void {
    const videoElement = document.querySelector('video') as HTMLVideoElement;
    if (videoElement) {
      videoElement.currentTime = timestamp;
    }
  }

  /**
   * Get chapter marker position as percentage
   */
  getChapterPosition(chapter: VideoChapter): number {
    const duration = this.videoDuration();
    if (duration === 0) return 0;
    return (chapter.startTime / duration) * 100;
  }

  /**
   * Handle click on progress bar to seek to position
   */
  onProgressBarClick(event: MouseEvent): void {
    const progressBar = event.currentTarget as HTMLElement;
    const rect = progressBar.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const width = rect.width;
    const percentage = (clickX / width) * 100;
    const seekTime = (percentage / 100) * this.videoDuration();
    this.seekToTime(seekTime);
  }

  /**
   * Legacy Quiz methods
   */
  selectQuizAnswer(answerIndex: number): void {
    const answers = [...this.quizAnswers()];
    answers[this.currentQuizIndex()] = answerIndex;
    this.quizAnswers.set(answers);
  }

  nextQuiz(): void {
    const currentIndex = this.currentQuizIndex();
    const totalQuizzes = this.quizzes().length;

    if (currentIndex < totalQuizzes - 1) {
      this.currentQuizIndex.set(currentIndex + 1);
    } else {
      this.finishQuiz();
    }
  }

  previousQuiz(): void {
    const currentIndex = this.currentQuizIndex();
    if (currentIndex > 0) {
      this.currentQuizIndex.set(currentIndex - 1);
    }
  }

  finishQuiz(): void {
    const answers = this.quizAnswers();
    const quizzes = this.quizzes();
    let correct = 0;

    answers.forEach((answer, index) => {
      if (answer === quizzes[index]?.correctAnswer) {
        correct++;
      }
    });

    this.quizScore.set(Math.round((correct / quizzes.length) * 100));
    this.showQuizResults.set(true);
  }

  resetQuiz(): void {
    this.currentQuizIndex.set(0);
    this.quizAnswers.set(new Array(this.quizzes().length).fill(-1));
    this.showQuizResults.set(false);
    this.quizScore.set(0);
  }

  /**
   * Resource methods
   */
  downloadResource(resource: LessonResource): void {
    if (resource.downloadable) {
      window.open(resource.url, '_blank');
    } else {
      this.router.navigate([resource.url]);
    }
  }

  /**
   * Navigation methods
   */
  goBack(): void {
    const lesson = this.lesson();
    if (lesson) {
      this.router.navigate(['/lessons'], {
        queryParams: {
          subject: lesson.subject,
          courseId: lesson.courseId
        }
      });
    } else {
      this.router.navigate(['/courses']);
    }
  }

  goToPreviousLesson(): void {
    const prevLesson = this.previousLesson();
    if (prevLesson) {
      this.router.navigate(['/lesson', prevLesson.id]);
    }
  }

  goToNextLesson(): void {
    const nextLesson = this.nextLesson();
    if (nextLesson) {
      this.router.navigate(['/lesson', nextLesson.id]);
    }
  }

  /**
   * Utility methods
   */
  formatTime(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  formatTimestamp(seconds: number): string {
    return this.formatTime(seconds);
  }

  getResourceIcon(type: string): string {
    switch (type) {
      case 'pdf': return 'fas fa-file-pdf';
      case 'exercise': return 'fas fa-dumbbell';
      case 'quiz': return 'fas fa-question-circle';
      case 'worksheet': return 'fas fa-file-alt';
      default: return 'fas fa-file';
    }
  }

  getResourceColor(type: string): string {
    switch (type) {
      case 'pdf': return 'text-red-600';
      case 'exercise': return 'text-blue-600';
      case 'quiz': return 'text-green-600';
      case 'worksheet': return 'text-purple-600';
      default: return 'text-gray-600';
    }
  }

  getOptionLetter(index: number): string {
    return String.fromCharCode(65 + index);
  }

  // ==================== VIDEO CHAPTER METHODS ====================

  jumpToChapter(chapter: VideoChapter): void {
    this.seekToTime(chapter.startTime);
  }

  addChapter(): void {
    if (this.chapterForm.valid && this.canEditContent()) {
      const formValue = this.chapterForm.value;
      const newChapter: VideoChapter = {
        id: Date.now(),
        title: formValue.title,
        startTime: formValue.startTime,
        endTime: formValue.endTime,
        description: formValue.description
      };

      const currentChapters = this.videoChapters();
      this.videoChapters.set([...currentChapters, newChapter].sort((a, b) => a.startTime - b.startTime));

      this.chapterForm.reset();
      this.toastService.success('Chapter added successfully');
    }
  }

  deleteChapter(chapterId: number): void {
    if (this.canEditContent() && confirm('Are you sure you want to delete this chapter?')) {
      const currentChapters = this.videoChapters();
      this.videoChapters.set(currentChapters.filter(chapter => chapter.id !== chapterId));
      this.toastService.success('Chapter deleted successfully');
    }
  }

  toggleChapterEditing(): void {
    this.isEditingChapters.set(!this.isEditingChapters());
    if (!this.isEditingChapters()) {
      this.chapterForm.reset();
    }
  }

  // ==================== QUIZ MAKER METHODS ====================

  startCreatingQuiz(): void {
    if (this.canEditContent()) {
      this.isCreatingQuiz.set(true);
      this.quizMakerForm.reset();
      this.quizQuestionForm.reset();
      this.currentQuizMaker.set({
        id: 0,
        lessonId: this.lesson()?.id || 0,
        title: '',
        description: '',
        timeLimit: 30,
        questions: [],
        passingScore: 70,
        isActive: true,
        createdBy: 'Current User',
        createdAt: new Date(),
        updatedAt: new Date()
      });
    }
  }

  addQuestionToQuiz(): void {
    if (this.quizQuestionForm.valid) {
      const formValue = this.quizQuestionForm.value;
      const newQuestion: QuizQuestion = {
        id: Date.now(),
        question: formValue.question,
        options: [formValue.option1, formValue.option2, formValue.option3, formValue.option4],
        correctAnswer: formValue.correctAnswer,
        explanation: formValue.explanation || '',
        points: formValue.points
      };

      const currentQuiz = this.currentQuizMaker();
      if (currentQuiz) {
        currentQuiz.questions.push(newQuestion);
        this.currentQuizMaker.set({ ...currentQuiz });
      }

      this.quizQuestionForm.reset();
      this.quizQuestionForm.patchValue({ correctAnswer: 0, points: 1 });
    }
  }

  removeQuestionFromQuiz(questionId: number): void {
    const currentQuiz = this.currentQuizMaker();
    if (currentQuiz) {
      currentQuiz.questions = currentQuiz.questions.filter(q => q.id !== questionId);
      this.currentQuizMaker.set({ ...currentQuiz });
    }
  }

  saveQuiz(): void {
    if (this.quizMakerForm.valid && this.currentQuizMaker()?.questions.length! > 0) {
      const formValue = this.quizMakerForm.value;
      const currentQuiz = this.currentQuizMaker()!;

      const quizToSave: QuizMaker = {
        ...currentQuiz,
        title: formValue.title,
        description: formValue.description,
        timeLimit: formValue.timeLimit,
        passingScore: formValue.passingScore,
        isActive: formValue.isActive,
        updatedAt: new Date()
      };

      if (quizToSave.id === 0) {
        quizToSave.id = Date.now();
        const currentQuizzes = this.quizMakers();
        this.quizMakers.set([...currentQuizzes, quizToSave]);
      } else {
        const currentQuizzes = this.quizMakers();
        const updatedQuizzes = currentQuizzes.map(q => q.id === quizToSave.id ? quizToSave : q);
        this.quizMakers.set(updatedQuizzes);
      }

      this.cancelQuizCreation();
      this.toastService.success('Quiz saved successfully');
    }
  }

  editQuiz(quiz: QuizMaker): void {
    if (this.canEditContent()) {
      this.isEditingQuiz.set(true);
      this.isCreatingQuiz.set(true);
      this.currentQuizMaker.set({ ...quiz });
      this.quizMakerForm.patchValue({
        title: quiz.title,
        description: quiz.description,
        timeLimit: quiz.timeLimit,
        passingScore: quiz.passingScore,
        isActive: quiz.isActive
      });
    }
  }

  deleteQuiz(quizId: number): void {
    if (this.canEditContent() && confirm('Are you sure you want to delete this quiz?')) {
      const currentQuizzes = this.quizMakers();
      this.quizMakers.set(currentQuizzes.filter(q => q.id !== quizId));
      this.toastService.success('Quiz deleted successfully');
    }
  }

  cancelQuizCreation(): void {
    this.isCreatingQuiz.set(false);
    this.isEditingQuiz.set(false);
    this.currentQuizMaker.set(null);
    this.quizMakerForm.reset();
    this.quizQuestionForm.reset();
  }

  toggleQuizStatus(quizId: number): void {
    if (this.canEditContent()) {
      const currentQuizzes = this.quizMakers();
      const updatedQuizzes = currentQuizzes.map(quiz =>
        quiz.id === quizId ? { ...quiz, isActive: !quiz.isActive, updatedAt: new Date() } : quiz
      );
      this.quizMakers.set(updatedQuizzes);
    }
  }

  getTotalQuizPoints(): number {
    const currentQuiz = this.currentQuizMaker();
    return currentQuiz?.questions.reduce((total, q) => total + q.points, 0) || 0;
  }

  getQuizTotalPoints(quiz: QuizMaker): number {
    return quiz.questions.reduce((total, q) => total + q.points, 0);
  }

  // ==================== POSTER MANAGEMENT METHODS ====================

  onPosterImageError(event: any): void {
    console.warn('Poster image failed to load, using fallback');
    event.target.style.display = 'none';
  }

  updatePosterUrl(newUrl: string): void {
    const currentLesson = this.lesson();
    if (currentLesson) {
      currentLesson.posterUrl = newUrl.trim() || currentLesson.posterUrl || 'https://via.placeholder.com/800x450/3B82F6/FFFFFF?text=No+Poster';
      this.toastService.info('Poster URL updated');
    }
  }

  generatePosterFromThumbnail(): void {
    const currentLesson = this.lesson();
    if (currentLesson && currentLesson.thumbnailUrl) {
      currentLesson.posterUrl = currentLesson.thumbnailUrl;
      this.toastService.success('Poster generated from thumbnail');
    }
  }

  clearPoster(): void {
    const currentLesson = this.lesson();
    if (currentLesson) {
      currentLesson.posterUrl = 'https://via.placeholder.com/800x450/3B82F6/FFFFFF?text=No+Poster';
      this.toastService.info('Poster cleared');
    }
  }

  saveLessonSettings(): void {
    const currentLesson = this.lesson();
    if (currentLesson) {
      console.log('Saving lesson settings:', currentLesson);
      this.toastService.success('Lesson settings saved successfully');
    }
  }

  getVideoPosterUrl(): string | undefined {
    const lesson = this.lesson();
    if (!lesson) return undefined;
    return lesson.posterUrl || lesson.thumbnailUrl || '/assets/img/default-video-poster.jpg';
  }

  getChapterWidth(chapter: VideoChapter): number {
    const duration = this.videoDuration();
    if (duration === 0) return 0;
    const chapterDuration = chapter.endTime - chapter.startTime;
    return (chapterDuration / duration) * 100;
  }

  getChapterColor(index: number): string {
    const colors = ['blue-200', 'green-200', 'yellow-200', 'purple-200', 'pink-200', 'indigo-200', 'red-200', 'orange-200'];
    return colors[index % colors.length];
  }

  getCurrentChapterIndex(): number {
    const current = this.currentChapter();
    if (!current) return -1;
    return this.videoChapters().findIndex(c => c.id === current.id);
  }
}
